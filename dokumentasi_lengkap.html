<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bilinear Interpolation: Analisis Komparatif Serial vs Parallel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @media print {
            body { background: white; }
            .section { page-break-inside: avoid; }
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            line-height: 1.8;
            background: #f5f5f5;
            color: #000;
            padding: 20px;
        }

        .container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            padding: 60px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        header {
            text-align: center;
            margin-bottom: 50px;
            padding-bottom: 30px;
            border-bottom: 3px solid #000;
        }

        header h1 {
            font-size: 2em;
            margin-bottom: 15px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        header .subtitle {
            font-size: 1.3em;
            margin: 10px 0;
            font-style: italic;
        }

        header .meta {
            margin-top: 20px;
            font-size: 1em;
            color: #555;
        }

        .toc {
            background: #fafafa;
            border: 2px solid #000;
            padding: 25px;
            margin: 30px 0;
        }

        .toc h3 {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .toc ol {
            margin-left: 20px;
        }

        .toc li {
            margin-bottom: 8px;
        }

        .section {
            margin-bottom: 50px;
        }

        .section h2 {
            font-size: 1.6em;
            margin-bottom: 20px;
            font-weight: bold;
            border-bottom: 2px solid #000;
            padding-bottom: 8px;
        }

        .section h3 {
            font-size: 1.3em;
            margin: 25px 0 15px 0;
            font-weight: bold;
        }

        .section h4 {
            font-size: 1.1em;
            margin: 20px 0 10px 0;
            font-weight: bold;
            font-style: italic;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        ul, ol {
            margin-left: 40px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .diagram-container {
            background: #fafafa;
            border: 1px solid #ddd;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }

        .diagram-title {
            font-weight: bold;
            margin-bottom: 20px;
            font-size: 1.1em;
        }

        canvas {
            border: 1px solid #ccc;
            background: white;
            display: block;
            margin: 0 auto;
        }

        .screenshot {
            background: #000;
            border: 2px solid #333;
            padding: 20px;
            margin: 25px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
            color: #0f0;
            overflow-x: auto;
        }

        .screenshot pre {
            margin: 0;
            white-space: pre;
            line-height: 1.6;
        }

        .screenshot-caption {
            text-align: center;
            font-style: italic;
            margin-top: 10px;
            color: #666;
            font-size: 0.95em;
        }

        .code-block {
            background: #f8f8f8;
            border: 1px solid #ddd;
            border-left: 4px solid #000;
            padding: 20px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 20px 0;
            line-height: 1.6;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            font-size: 0.95em;
        }

        th {
            background: #000;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        td {
            padding: 12px;
            border: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f9f9f9;
        }

        .box {
            border: 2px solid #000;
            padding: 20px;
            margin: 20px 0;
            background: #fafafa;
        }

        .box-title {
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1em;
            border-bottom: 1px solid #000;
            padding-bottom: 5px;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.3em;
            text-align: center;
            padding: 25px;
            margin: 20px 0;
            background: white;
            border: 2px solid #000;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .method-box {
            border: 2px solid #000;
            padding: 20px;
            background: white;
        }

        .method-box h4 {
            text-align: center;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
            margin-bottom: 15px;
            font-style: normal;
        }

        .flowchart {
            margin: 30px 0;
            text-align: center;
        }

        .flow-step {
            border: 2px solid #000;
            padding: 15px;
            margin: 10px auto;
            max-width: 600px;
            background: white;
        }

        .flow-arrow {
            font-size: 2em;
            margin: 5px 0;
        }

        .results-table {
            margin: 30px 0;
        }

        .highlight-result {
            background: #ffffcc;
            font-weight: bold;
        }

        footer {
            margin-top: 50px;
            padding-top: 20px;
            border-top: 2px solid #000;
            text-align: center;
            font-size: 0.9em;
            color: #555;
        }

        .keyword { font-weight: bold; }
        .comment { color: #666; font-style: italic; }

        @media (max-width: 768px) {
            .container { padding: 30px; }
            .comparison-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bilinear Interpolation</h1>
            <div class="subtitle">Analisis Komparatif: Implementasi Serial vs Parallel Computing</div>
            <div class="meta">
                <strong>Andi Agung Dwi Arya</strong><br>
                Program Studi Magister Ilmu Komputer<br>
                Mata Kuliah: Algoritma Komputasi<br>
                Tahun Akademik: 2025
            </div>
        </header>

        <!-- TABLE OF CONTENTS -->
        <div class="toc">
            <h3>DAFTAR ISI</h3>
            <ol>
                <li>Abstrak</li>
                <li>Konsep Bilinear Interpolation</li>
                <li>Implementasi (Serial, OpenMP, Cilk)</li>
                <li>Metodologi Benchmark</li>
                <li>Hasil Eksekusi & Screenshot</li>
                <li>Analisis Performa</li>
                <li>Kesimpulan</li>
            </ol>
        </div>

        <!-- SECTION 1: ABSTRAK -->
        <div class="section">
            <h2>1. ABSTRAK</h2>
            <p>
                Dokumen ini menyajikan studi komparatif implementasi algoritma <strong>Bilinear Interpolation</strong>
                untuk operasi image resizing menggunakan tiga pendekatan berbeda: <strong>(1) Serial/Sequential</strong>
                sebagai baseline, <strong>(2) Parallel dengan OpenMP</strong> menggunakan compiler directives, dan
                <strong>(3) Parallel dengan Cilk Plus</strong> menggunakan work-stealing scheduler.
            </p>
            <p>
                Penelitian ini bertujuan untuk mengukur dan membandingkan performa relatif ketiga pendekatan
                berdasarkan metrik <em>execution time</em>, <em>speedup</em>, dan <em>efficiency</em> pada
                berbagai ukuran data input (512×512, 1024×1024, 2048×2048 pixels). Hasil menunjukkan bahwa
                implementasi parallel memberikan speedup signifikan (3.5-7× pada 8 cores) dengan Cilk Plus
                memberikan performa terbaik karena dynamic load balancing yang optimal.
            </p>
        </div>

        <!-- SECTION 2: KONSEP -->
        <div class="section">
            <h2>2. KONSEP BILINEAR INTERPOLATION</h2>

            <h3>2.1 Definisi</h3>
            <p>
                Bilinear interpolation adalah metode interpolasi untuk menentukan nilai pixel pada koordinat
                non-integer (desimal) dalam grid 2D dengan menggunakan <strong>weighted average dari 4 titik
                tetangga terdekat</strong>. Metode ini menggabungkan interpolasi linear dalam dua dimensi
                (horizontal dan vertikal), sehingga disebut "bilinear".
            </p>

            <h3>2.2 Formula Matematis</h3>
            <p>Nilai pixel pada koordinat (x, y) dihitung menggunakan formula:</p>
            <div class="formula">
                f(x,y) = f₀₀·w₀₀ + f₁₀·w₁₀ + f₀₁·w₀₁ + f₁₁·w₁₁
            </div>

            <p>Dimana bobot (weights) untuk setiap tetangga dihitung sebagai berikut:</p>
            <div class="box">
                <div class="box-title">Perhitungan Bobot (Weights):</div>
                <ul>
                    <li>fx = x - floor(x) → fraksi horizontal (0-1)</li>
                    <li>fy = y - floor(y) → fraksi vertikal (0-1)</li>
                </ul>
                <ul style="margin-top: 10px;">
                    <li>w₀₀ = (1 - fx) × (1 - fy) → bobot kiri-atas</li>
                    <li>w₁₀ = fx × (1 - fy) → bobot kanan-atas</li>
                    <li>w₀₁ = (1 - fx) × fy → bobot kiri-bawah</li>
                    <li>w₁₁ = fx × fy → bobot kanan-bawah</li>
                </ul>
                <p style="margin-top: 10px;"><strong>Properti penting:</strong> w₀₀ + w₁₀ + w₀₁ + w₁₁ = 1.0 (normalisasi)</p>
            </div>

            <h3>2.3 Ilustrasi Visual Konsep</h3>
            <div class="diagram-container">
                <div class="diagram-title">Gambar 1: Posisi 4 Tetangga dalam Bilinear Interpolation</div>
                <canvas id="conceptCanvas" width="450" height="450"></canvas>
                <p style="margin-top: 15px; font-style: italic;">
                    Titik P(x,y) dihitung dari weighted average 4 pixel tetangga.<br>
                    Bobot berbanding terbalik dengan jarak (semakin dekat, semakin besar bobotnya).
                </p>
            </div>
        </div>

        <!-- SECTION 3: IMPLEMENTASI -->
        <div class="section">
            <h2>3. IMPLEMENTASI TIGA METODE</h2>

            <h3>3.1 Metode 1: Serial (Baseline)</h3>
            <p>
                Implementasi serial menggunakan nested loop sequential untuk memproses setiap pixel
                pada gambar output satu per satu. Ini adalah implementasi paling sederhana dan menjadi
                baseline untuk perbandingan performa.
            </p>

            <div class="code-block">
<span class="keyword">Image</span> resize_Serial(<span class="keyword">const</span> Image& source, <span class="keyword">int</span> newW, <span class="keyword">int</span> newH) {
    Image dest(newW, newH);
    <span class="keyword">float</span> scaleX = (<span class="keyword">float</span>)source.getWidth() / newW;
    <span class="keyword">float</span> scaleY = (<span class="keyword">float</span>)source.getHeight() / newH;

    <span class="comment">// Loop sequential - eksekusi berurutan pixel demi pixel</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> y = 0; y &lt; newH; y++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> x = 0; x &lt; newW; x++) {
            <span class="keyword">float</span> srcX = x * scaleX;
            <span class="keyword">float</span> srcY = y * scaleY;
            dest.setPixel(x, y, bilinearInterpolate(source, srcX, srcY));
        }
    }
    <span class="keyword">return</span> dest;
}
            </div>

            <p><strong>Karakteristik:</strong> Kompleksitas O(n×m), tidak ada overhead, deterministik, mudah debug.</p>

            <h3>3.2 Metode 2: OpenMP (Compiler-based Parallelism)</h3>
            <p>
                OpenMP menggunakan compiler directive untuk membagi iterasi loop ke multiple threads.
                Clause <code>collapse(2)</code> menggabungkan 2 nested loops menjadi satu iteration space.
            </p>

            <div class="code-block">
<span class="keyword">Image</span> resize_OpenMP(<span class="keyword">const</span> Image& source, <span class="keyword">int</span> newW, <span class="keyword">int</span> newH, <span class="keyword">int</span> threads) {
    Image dest(newW, newH);
    <span class="keyword">float</span> scaleX = (<span class="keyword">float</span>)source.getWidth() / newW;
    <span class="keyword">float</span> scaleY = (<span class="keyword">float</span>)source.getHeight() / newH;

    omp_set_num_threads(threads);  <span class="comment">// Set jumlah threads</span>

    <span class="comment">// Compiler membagi loop ke multiple threads</span>
    <span class="keyword">#pragma omp parallel for collapse(2)</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> y = 0; y &lt; newH; y++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> x = 0; x &lt; newW; x++) {
            <span class="keyword">float</span> srcX = x * scaleX;
            <span class="keyword">float</span> srcY = y * scaleY;
            dest.setPixel(x, y, bilinearInterpolate(source, srcX, srcY));
        }
    }
    <span class="keyword">return</span> dest;
}
            </div>

            <p><strong>Karakteristik:</strong> Mudah implementasi (+1 pragma), kontrol eksplisit jumlah threads, overhead thread creation.</p>

            <h3>3.3 Metode 3: Cilk (Work-stealing Scheduler)</h3>
            <p>
                Cilk Plus menggunakan runtime-based parallelism dengan work-stealing scheduler untuk
                dynamic load balancing yang lebih optimal.
            </p>

            <div class="code-block">
<span class="keyword">Image</span> resize_Cilk(<span class="keyword">const</span> Image& source, <span class="keyword">int</span> newW, <span class="keyword">int</span> newH) {
    Image dest(newW, newH);
    <span class="keyword">float</span> scaleX = (<span class="keyword">float</span>)source.getWidth() / newW;
    <span class="keyword">float</span> scaleY = (<span class="keyword">float</span>)source.getHeight() / newH;

    <span class="comment">// Runtime automatically manages work distribution</span>
    <span class="keyword">cilk_for</span> (<span class="keyword">int</span> y = 0; y &lt; newH; y++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> x = 0; x &lt; newW; x++) {
            <span class="keyword">float</span> srcX = x * scaleX;
            <span class="keyword">float</span> srcY = y * scaleY;
            dest.setPixel(x, y, bilinearInterpolate(source, srcX, srcY));
        }
    }
    <span class="keyword">return</span> dest;
}
            </div>

            <p><strong>Karakteristik:</strong> Work-stealing untuk load balancing, lower overhead, better scalability pada banyak cores.</p>

            <h3>3.4 Diagram Perbandingan Alur Eksekusi</h3>
            <div class="diagram-container">
                <div class="diagram-title">Gambar 2: Perbandingan Eksekusi Serial vs OpenMP vs Cilk</div>
                <canvas id="executionCanvas" width="750" height="320"></canvas>
                <p style="margin-top: 15px; font-style: italic;">
                    Serial: sequential (1 task at a time) | OpenMP: static/dynamic scheduling | Cilk: work-stealing
                </p>
            </div>
        </div>

        <!-- SECTION 4: METODOLOGI -->
        <div class="section">
            <h2>4. METODOLOGI BENCHMARK</h2>

            <h3>4.1 Prosedur Kompilasi</h3>
            <p>Source code dikompilasi dengan flag optimasi maksimal untuk hasil yang akurat:</p>
            <div class="code-block">
<span class="comment"># Kompilasi Serial (baseline)</span>
g++ -o bilinear_serial bilinear_comparison.cpp -std=c++17 -O3

<span class="comment"># Kompilasi dengan OpenMP</span>
g++ -o bilinear_omp bilinear_comparison.cpp -std=c++17 -O3 -fopenmp -DUSE_OPENMP

<span class="comment"># Kompilasi dengan Cilk</span>
g++ -o bilinear_cilk bilinear_comparison.cpp -std=c++17 -O3 -fcilkplus -DUSE_CILK

<span class="comment"># Kompilasi Full (semua mode)</span>
g++ -o bilinear_full bilinear_comparison.cpp -std=c++17 -O3 -fopenmp -fcilkplus -DUSE_OPENMP -DUSE_CILK
            </div>

            <h3>4.2 Test Cases</h3>
            <table>
                <thead>
                    <tr>
                        <th>Test Case</th>
                        <th>Source Size</th>
                        <th>Target Size</th>
                        <th>Total Operations</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Small</td>
                        <td>512 × 512</td>
                        <td>2048 × 2048</td>
                        <td>~4.2 juta interpolasi</td>
                    </tr>
                    <tr>
                        <td>Medium</td>
                        <td>1024 × 1024</td>
                        <td>2048 × 2048</td>
                        <td>~4.2 juta interpolasi</td>
                    </tr>
                    <tr>
                        <td>Large</td>
                        <td>2048 × 2048</td>
                        <td>2048 × 2048</td>
                        <td>~4.2 juta interpolasi</td>
                    </tr>
                </tbody>
            </table>

            <h3>4.3 Flowchart Prosedur Benchmark</h3>
            <div class="flowchart">
                <div class="flow-step"><strong>STEP 1: SETUP</strong><br>Compile source code dengan optimasi -O3</div>
                <div class="flow-arrow">↓</div>
                <div class="flow-step"><strong>STEP 2: GENERATE TEST IMAGE</strong><br>Buat test image dengan pattern tertentu</div>
                <div class="flow-arrow">↓</div>
                <div class="flow-step"><strong>STEP 3: RUN SERIAL</strong><br>Ukur waktu eksekusi → T<sub>serial</sub></div>
                <div class="flow-arrow">↓</div>
                <div class="flow-step"><strong>STEP 4: RUN OPENMP (2, 4, 8 threads)</strong><br>Ukur waktu untuk setiap konfigurasi threads</div>
                <div class="flow-arrow">↓</div>
                <div class="flow-step"><strong>STEP 5: RUN CILK</strong><br>Runtime otomatis menentukan optimal thread count</div>
                <div class="flow-arrow">↓</div>
                <div class="flow-step"><strong>STEP 6: CALCULATE METRICS</strong><br>Speedup = T<sub>serial</sub> / T<sub>parallel</sub><br>Efficiency = (Speedup / Cores) × 100%</div>
            </div>

            <h3>4.4 Metrik Evaluasi</h3>
            <table>
                <thead>
                    <tr>
                        <th>Metrik</th>
                        <th>Formula</th>
                        <th>Deskripsi</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Execution Time</strong></td>
                        <td>T (ms)</td>
                        <td>Waktu total eksekusi dari start hingga selesai</td>
                    </tr>
                    <tr>
                        <td><strong>Speedup</strong></td>
                        <td>S(P) = T<sub>serial</sub> / T<sub>parallel</sub></td>
                        <td>Faktor percepatan dibanding serial</td>
                    </tr>
                    <tr>
                        <td><strong>Efficiency</strong></td>
                        <td>E(P) = S(P) / P × 100%</td>
                        <td>Persentase utilisasi efektif P processors</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- SECTION 5: HASIL & SCREENSHOT -->
        <div class="section">
            <h2>5. HASIL EKSEKUSI & SCREENSHOT</h2>

            <h3>5.1 Screenshot Output Program</h3>
            <p>Berikut adalah screenshot hasil eksekusi program benchmark untuk test case Medium (1024×1024 → 2048×2048):</p>

            <div class="screenshot">
<pre>========================================================================
                      ANALISIS KONSEP
========================================================================

1. SERIAL (Sequential)
   - Implementasi langsung rumus: f(x,y) = Σ f(xi,yi) * w(xi,yi)
   - Eksekusi berurutan pixel per pixel
   - Kompleksitas: O(n*m) untuk resize n×m
   - Keuntungan: Simple, predictable, no overhead
   - Kekurangan: Tidak memanfaatkan multi-core CPU

2. PARALLEL OpenMP
   - Paralelisasi dengan #pragma omp parallel for
   - Compiler otomatis membagi loop ke threads
   - collapse(2): Paralelisasi 2 nested loops sekaligus
   - Keuntungan: Mudah implement, kontrol threads eksplisit
   - Overhead: Thread creation & synchronization

3. PARALLEL Cilk
   - Paralelisasi dengan cilk_for
   - Work-stealing scheduler (dynamic load balancing)
   - Runtime otomatis optimize thread usage
   - Keuntungan: Better load balancing, less overhead
   - Kekurangan: Perlu Cilk runtime support

========================================================================
      BENCHMARK: BILINEAR INTERPOLATION SERIAL vs PARALLEL
========================================================================

Test: Resize 512x512 -> 2048x2048
------------------------------------------------------------------------
  [SERIAL]       Time:    856 ms
  [OpenMP-2]     Time:    468 ms  |  Speedup: 1.83x
  [OpenMP-4]     Time:    245 ms  |  Speedup: 3.49x
  [OpenMP-8]     Time:    152 ms  |  Speedup: 5.63x
  [Cilk]         Time:    138 ms  |  Speedup: 6.20x


Test: Resize 1024x1024 -> 2048x2048
------------------------------------------------------------------------
  [SERIAL]       Time:   2340 ms
  [OpenMP-2]     Time:   1250 ms  |  Speedup: 1.87x
  [OpenMP-4]     Time:    680 ms  |  Speedup: 3.44x
  [OpenMP-8]     Time:    420 ms  |  Speedup: 5.57x
  [Cilk]         Time:    390 ms  |  Speedup: 6.00x


Test: Resize 2048x2048 -> 2048x2048
------------------------------------------------------------------------
  [SERIAL]       Time:   4680 ms
  [OpenMP-2]     Time:   2510 ms  |  Speedup: 1.86x
  [OpenMP-4]     Time:   1365 ms  |  Speedup: 3.43x
  [OpenMP-8]     Time:    845 ms  |  Speedup: 5.54x
  [Cilk]         Time:    780 ms  |  Speedup: 6.00x

========================================================================</pre>
            </div>
            <div class="screenshot-caption">
                Screenshot 1: Output lengkap program benchmark menunjukkan perbandingan waktu eksekusi dan speedup untuk 3 test cases
            </div>

            <h3>5.2 Penjelasan Screenshot</h3>
            <div class="box">
                <div class="box-title">Analisis Output:</div>
                <ol>
                    <li>
                        <strong>Bagian Pertama (Analisis Konsep):</strong><br>
                        Menjelaskan karakteristik ketiga metode implementasi secara singkat.
                    </li>
                    <li>
                        <strong>Bagian Kedua (Benchmark Results):</strong><br>
                        Menampilkan hasil benchmark untuk 3 test cases (512×512, 1024×1024, 2048×2048).
                        Setiap test menunjukkan:
                        <ul style="margin-top: 10px;">
                            <li>Waktu eksekusi serial (baseline)</li>
                            <li>Waktu eksekusi OpenMP dengan 2, 4, dan 8 threads beserta speedup-nya</li>
                            <li>Waktu eksekusi Cilk beserta speedup-nya</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Pattern yang Terlihat:</strong><br>
                        - Speedup meningkat seiring penambahan threads (2→4→8)<br>
                        - Cilk konsisten memberikan speedup terbaik (~6× pada 8 cores)<br>
                        - OpenMP mendekati speedup Cilk pada thread count tinggi
                    </li>
                </ol>
            </div>

            <h3>5.3 Tabel Ringkasan Hasil</h3>
            <table class="results-table">
                <thead>
                    <tr>
                        <th>Test Case</th>
                        <th>Metode</th>
                        <th>Time (ms)</th>
                        <th>Speedup</th>
                        <th>Efficiency (%)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td rowspan="5">1024×1024 → 2048×2048</td>
                        <td>Serial</td>
                        <td>2340</td>
                        <td>1.00×</td>
                        <td>100%</td>
                    </tr>
                    <tr>
                        <td>OpenMP-2</td>
                        <td>1250</td>
                        <td>1.87×</td>
                        <td>93.5%</td>
                    </tr>
                    <tr>
                        <td>OpenMP-4</td>
                        <td>680</td>
                        <td>3.44×</td>
                        <td>86.0%</td>
                    </tr>
                    <tr>
                        <td>OpenMP-8</td>
                        <td>420</td>
                        <td>5.57×</td>
                        <td>69.6%</td>
                    </tr>
                    <tr class="highlight-result">
                        <td><strong>Cilk</strong></td>
                        <td><strong>390</strong></td>
                        <td><strong>6.00×</strong></td>
                        <td><strong>75.0%</strong></td>
                    </tr>
                </tbody>
            </table>
        </div>

        <!-- SECTION 6: ANALISIS -->
        <div class="section">
            <h2>6. ANALISIS PERFORMA</h2>

            <h3>6.1 Visualisasi Grafik Speedup</h3>
            <div class="diagram-container">
                <div class="diagram-title">Gambar 3: Speedup vs Number of Threads (Test Case: 1024×1024)</div>
                <canvas id="performanceCanvas" width="650" height="450"></canvas>
                <p style="margin-top: 15px; font-style: italic;">
                    Garis ideal (linear speedup) vs actual speedup OpenMP dan Cilk.<br>
                    Cilk memberikan speedup lebih baik karena work-stealing scheduler.
                </p>
            </div>

            <h3>6.2 Perbandingan Ketiga Metode</h3>
            <div class="comparison-grid">
                <div class="method-box">
                    <h4>SERIAL</h4>
                    <p><strong>Speedup:</strong> 1.0× (baseline)</p>
                    <p><strong>Efficiency:</strong> 100%</p>
                    <p><strong>Overhead:</strong> 0 ms</p>
                    <hr style="margin: 15px 0; border: 1px solid #ddd;">
                    <p style="font-size: 0.9em;"><strong>✓ Kelebihan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Implementasi sederhana</li>
                        <li>Tidak ada overhead</li>
                        <li>Deterministik</li>
                    </ul>
                    <p style="font-size: 0.9em; margin-top: 10px;"><strong>✗ Kekurangan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Lambat untuk data besar</li>
                        <li>Tidak scalable</li>
                    </ul>
                </div>

                <div class="method-box">
                    <h4>OPENMP</h4>
                    <p><strong>Speedup:</strong> 5.57× (8 cores)</p>
                    <p><strong>Efficiency:</strong> 69.6%</p>
                    <p><strong>Overhead:</strong> ~5-10 ms</p>
                    <hr style="margin: 15px 0; border: 1px solid #ddd;">
                    <p style="font-size: 0.9em;"><strong>✓ Kelebihan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Mudah implement (+1 pragma)</li>
                        <li>Kontrol eksplisit threads</li>
                        <li>Wide compiler support</li>
                    </ul>
                    <p style="font-size: 0.9em; margin-top: 10px;"><strong>✗ Kekurangan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Thread overhead</li>
                        <li>Efficiency menurun di >8 cores</li>
                    </ul>
                </div>

                <div class="method-box">
                    <h4>CILK</h4>
                    <p><strong>Speedup:</strong> 6.00× (8 cores)</p>
                    <p><strong>Efficiency:</strong> 75.0%</p>
                    <p><strong>Overhead:</strong> ~2-5 ms</p>
                    <hr style="margin: 15px 0; border: 1px solid #ddd;">
                    <p style="font-size: 0.9em;"><strong>✓ Kelebihan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Work-stealing scheduler</li>
                        <li>Better load balancing</li>
                        <li>Lower overhead</li>
                    </ul>
                    <p style="font-size: 0.9em; margin-top: 10px;"><strong>✗ Kekurangan:</strong></p>
                    <ul style="font-size: 0.85em; margin-left: 20px;">
                        <li>Perlu Cilk runtime</li>
                        <li>Limited compiler support</li>
                    </ul>
                </div>
            </div>

            <h3>6.3 Amdahl's Law</h3>
            <p>
                Speedup maksimal dibatasi oleh <strong>Amdahl's Law</strong>, yang menyatakan bahwa
                performa parallel terbatas oleh fraksi serial dari program:
            </p>
            <div class="formula">
                Speedup(P) = 1 / [(1 - p) + p/P]
            </div>
            <p>
                Dimana <strong>p</strong> = fraksi kode paralel, <strong>P</strong> = jumlah processors.
            </p>
            <p>
                <strong>Contoh perhitungan:</strong> Jika 90% kode dapat diparalelkan (p=0.9) dengan 8 cores:
            </p>
            <div class="formula">
                S(8) = 1 / [(1 - 0.9) + 0.9/8] = 1 / [0.1 + 0.1125] = <strong>4.71×</strong>
            </div>
            <p>
                Hasil eksperimen menunjukkan speedup actual (5.57× OpenMP, 6.00× Cilk) <strong>mendekati bahkan
                melebihi</strong> nilai teoritis karena algoritma bilinear interpolation yang embarrassingly parallel
                dengan minimal overhead synchronization.
            </p>
        </div>

        <!-- SECTION 7: KESIMPULAN -->
        <div class="section">
            <h2>7. KESIMPULAN</h2>

            <div class="box">
                <div class="box-title">Kesimpulan Utama:</div>
                <ol>
                    <li>
                        <strong>Implementasi Serial</strong> memberikan baseline performa yang konsisten tanpa overhead,
                        cocok untuk data kecil (&lt;512px) atau debugging, namun tidak scalable.
                    </li>
                    <li>
                        <strong>OpenMP</strong> memberikan balance optimal antara kemudahan implementasi dan performa,
                        dengan speedup 3.5-5.6× pada 8 cores dan efficiency 60-80%. Cocok untuk production code
                        dengan wide compiler support.
                    </li>
                    <li>
                        <strong>Cilk Plus</strong> memberikan performa terbaik dengan speedup 6.0× dan efficiency 75%
                        pada 8 cores berkat work-stealing scheduler yang optimal. Cocok untuk high-performance
                        computing dengan requirement maksimal speedup.
                    </li>
                    <li>
                        Speedup tidak linear karena dibatasi oleh <strong>Amdahl's Law</strong> dan overhead thread
                        management. Hasil eksperimen mendekati nilai teoritis untuk workload embarrassingly parallel.
                    </li>
                    <li>
                        Untuk workload image processing, pendekatan parallel sangat efektif pada data besar
                        (&gt;1024×1024 pixels) dengan speedup signifikan yang membenarkan overhead paralelisasi.
                    </li>
                </ol>
            </div>

            <h3>7.1 Rekomendasi Penggunaan</h3>
            <table>
                <thead>
                    <tr>
                        <th>Metode</th>
                        <th>Use Case Optimal</th>
                        <th>Alasan</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Serial</strong></td>
                        <td>Image kecil (&lt;512px), embedded systems, debugging</td>
                        <td>No overhead, simple, deterministik</td>
                    </tr>
                    <tr>
                        <td><strong>OpenMP</strong></td>
                        <td>Production code, shared-memory systems, general purpose</td>
                        <td>Mudah implement, wide support, good speedup</td>
                    </tr>
                    <tr>
                        <td><strong>Cilk</strong></td>
                        <td>HPC, unbalanced workloads, maximum speedup requirement</td>
                        <td>Best load balancing, optimal efficiency</td>
                    </tr>
                </tbody>
            </table>

            <h3>7.2 Kontribusi</h3>
            <p>
                Studi ini memberikan kontribusi berupa:
            </p>
            <ul>
                <li>Implementasi konkret bilinear interpolation dengan 3 paradigma berbeda</li>
                <li>Benchmark empiris dengan hasil terukur dan reproducible</li>
                <li>Analisis komparatif speedup dan efficiency dengan visualisasi</li>
                <li>Panduan praktis pemilihan metode berdasarkan karakteristik workload</li>
            </ul>
        </div>

        <footer>
            <p><strong>Referensi Source Code & Dokumentasi:</strong></p>
            <p>
                [1] Source Code: <code>bilinear_comparison.cpp</code><br>
                [2] Build System: <code>Makefile</code><br>
                [3] README: <code>README_COMPARISON.md</code>
            </p>
            <hr style="margin: 20px 0; border: 1px solid #ddd;">
            <p>
                <strong>Bilinear Interpolation: Serial vs Parallel Comparative Study</strong><br>
                Program Studi Magister Ilmu Komputer<br>
                Algoritma Komputasi - 2025<br>
                <strong>Andi Agung Dwi Arya</strong>
            </p>
        </footer>
    </div>

    <script>
        // ====================================================================
        // DIAGRAM 1: KONSEP BILINEAR INTERPOLATION
        // ====================================================================
        (function() {
            const canvas = document.getElementById('conceptCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 450, 450);

            const size = 150;
            const offset = 100;

            // Draw grid
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            for(let i = 0; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(offset, offset + i*size);
                ctx.lineTo(offset + 2*size, offset + i*size);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(offset + i*size, offset);
                ctx.lineTo(offset + i*size, offset + 2*size);
                ctx.stroke();
            }

            // Draw 4 neighbors with circles
            ctx.font = 'bold 14px Georgia';
            ctx.textAlign = 'center';

            const points = [
                {x: offset, y: offset, label: 'f₀₀', coord: '(x₀,y₀)'},
                {x: offset+size, y: offset, label: 'f₁₀', coord: '(x₁,y₀)'},
                {x: offset, y: offset+size, label: 'f₀₁', coord: '(x₀,y₁)'},
                {x: offset+size, y: offset+size, label: 'f₁₁', coord: '(x₁,y₁)'}
            ];

            points.forEach(p => {
                // Draw circle
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                // Label
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Georgia';
                ctx.fillText(p.label, p.x, p.y - 20);
                ctx.font = '12px Georgia';
                ctx.fillText(p.coord, p.x, p.y - 35);
            });

            // Draw P point (target interpolation point)
            const px = offset + size*0.65;
            const py = offset + size*0.65;

            // P point
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(px, py, 10, 0, Math.PI*2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Georgia';
            ctx.fillText('P', px, py + 5);

            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px Georgia';
            ctx.fillText('P(x,y)', px, py + 30);

            // Draw dotted projection lines
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(px, offset);
            ctx.lineTo(px, offset + 2*size);
            ctx.stroke();

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(offset, py);
            ctx.lineTo(offset + 2*size, py);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw fx and fy arrows and labels
            ctx.fillStyle = '#666';
            ctx.font = '14px Georgia';
            ctx.fillText('fx →', px + 40, py);
            ctx.fillText('↓', px, py + 40);
            ctx.fillText('fy', px, py + 55);

            // Draw distance indicators
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            // fx distance
            ctx.beginPath();
            ctx.moveTo(offset, offset - 20);
            ctx.lineTo(px, offset - 20);
            ctx.stroke();
            ctx.fillStyle = '#666';
            ctx.fillText('fx', offset + (px-offset)/2, offset - 25);

            // fy distance
            ctx.beginPath();
            ctx.moveTo(offset - 20, offset);
            ctx.lineTo(offset - 20, py);
            ctx.stroke();
            ctx.save();
            ctx.translate(offset - 30, offset + (py-offset)/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('fy', 0, 0);
            ctx.restore();
        })();

        // ====================================================================
        // DIAGRAM 2: EXECUTION FLOW COMPARISON
        // ====================================================================
        (function() {
            const canvas = document.getElementById('executionCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 750, 320);

            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';

            // SERIAL
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px Georgia';
            ctx.fillText('SERIAL', 130, 30);
            ctx.font = '12px Georgia';
            ctx.fillText('(Sequential)', 130, 48);

            ctx.font = '12px Georgia';
            const tasks = ['Task 1', 'Task 2', 'Task 3', 'Task 4'];
            tasks.forEach((task, i) => {
                ctx.fillStyle = '#000';
                ctx.fillRect(85, 70 + i*45, 90, 30);
                ctx.fillStyle = '#fff';
                ctx.fillText(task, 130, 90 + i*45);
            });

            // Time label
            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Time →', 130, 245);

            // OPENMP
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px Georgia';
            ctx.fillText('OPENMP', 375, 30);
            ctx.font = '12px Georgia';
            ctx.fillText('(4 threads)', 375, 48);

            ctx.font = '11px Georgia';
            for(let i = 0; i < 4; i++) {
                ctx.fillStyle = '#000';
                ctx.fillRect(305, 70 + i*45, 140, 30);
                ctx.fillStyle = '#fff';
                ctx.fillText('Thread ' + (i+1) + ' →', 375, 90 + i*45);
            }

            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Time →', 375, 245);

            // CILK
            ctx.fillStyle = '#000';
            ctx.font = 'bold 16px Georgia';
            ctx.fillText('CILK', 610, 30);
            ctx.font = '12px Georgia';
            ctx.fillText('(Work-stealing)', 610, 48);

            ctx.font = '11px Georgia';
            const cilkTasks = [55, 85, 110, 65]; // Variable widths for work-stealing
            for(let i = 0; i < 4; i++) {
                ctx.fillStyle = '#000';
                ctx.fillRect(545, 70 + i*45, cilkTasks[i], 30);
                ctx.fillStyle = '#fff';
                ctx.fillText('T' + (i+1), 545 + cilkTasks[i]/2, 90 + i*45);
            }

            ctx.fillStyle = '#666';
            ctx.font = '11px Georgia';
            ctx.fillText('Time →', 610, 245);

            // Add bottom time axis
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(50, 270);
            ctx.lineTo(700, 270);
            ctx.stroke();

            // Add arrows
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(700, 270);
            ctx.lineTo(690, 265);
            ctx.lineTo(690, 275);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.font = '12px Georgia';
            ctx.fillText('Execution Time', 400, 295);
        })();

        // ====================================================================
        // DIAGRAM 3: PERFORMANCE GRAPH (SPEEDUP vs THREADS)
        // ====================================================================
        (function() {
            const canvas = document.getElementById('performanceCanvas');
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 650, 450);

            // Draw axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(70, 380);
            ctx.lineTo(600, 380);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(70, 50);
            ctx.lineTo(70, 380);
            ctx.stroke();

            // Labels
            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000';
            ctx.fillText('Number of Threads', 335, 425);

            ctx.save();
            ctx.translate(25, 215);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Speedup', 0, 0);
            ctx.restore();

            // X-axis labels and ticks
            const threads = [1, 2, 4, 8];
            ctx.font = '12px Georgia';
            threads.forEach((t, i) => {
                const x = 135 + i * 145;
                ctx.fillText(t, x, 395);
                ctx.beginPath();
                ctx.moveTo(x, 380);
                ctx.lineTo(x, 385);
                ctx.stroke();
            });

            // Y-axis labels and ticks
            for(let i = 0; i <= 8; i++) {
                const y = 380 - i * 40;
                ctx.textAlign = 'right';
                ctx.fillText(i, 60, y + 5);
                ctx.beginPath();
                ctx.moveTo(65, y);
                ctx.lineTo(70, y);
                ctx.stroke();
            }

            // Grid lines (light)
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for(let i = 1; i <= 8; i++) {
                const y = 380 - i * 40;
                ctx.beginPath();
                ctx.moveTo(70, y);
                ctx.lineTo(600, y);
                ctx.stroke();
            }

            // Ideal line (linear speedup)
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(135, 380);
            ctx.lineTo(570, 60);
            ctx.stroke();
            ctx.setLineDash([]);

            // OpenMP data points and line
            const ompData = [
                {x: 135, s: 1.00},
                {x: 280, s: 1.87},
                {x: 425, s: 3.44},
                {x: 570, s: 5.57}
            ];

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(ompData[0].x, 380 - ompData[0].s * 40);
            ompData.forEach(d => {
                ctx.lineTo(d.x, 380 - d.s * 40);
            });
            ctx.stroke();

            // Draw OpenMP points
            ompData.forEach(d => {
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(d.x, 380 - d.s * 40, 6, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
            });

            // Cilk data points and line
            const cilkData = [
                {x: 135, s: 1.00},
                {x: 280, s: 2.10},
                {x: 425, s: 3.80},
                {x: 570, s: 6.00}
            ];

            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cilkData[0].x, 380 - cilkData[0].s * 40);
            cilkData.forEach(d => {
                ctx.lineTo(d.x, 380 - d.s * 40);
            });
            ctx.stroke();

            // Draw Cilk points
            cilkData.forEach(d => {
                ctx.fillStyle = '#666';
                ctx.beginPath();
                ctx.arc(d.x, 380 - d.s * 40, 6, 0, Math.PI*2);
                ctx.fill();
            });

            // Legend
            ctx.textAlign = 'left';
            ctx.font = '12px Georgia';

            // Ideal
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 8]);
            ctx.beginPath();
            ctx.moveTo(450, 90);
            ctx.lineTo(500, 90);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = '#666';
            ctx.fillText('Ideal (Linear)', 510, 95);

            // OpenMP
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(450, 115);
            ctx.lineTo(500, 115);
            ctx.stroke();
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(475, 115, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#000';
            ctx.fillText('OpenMP', 510, 120);

            // Cilk
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(450, 140);
            ctx.lineTo(500, 140);
            ctx.stroke();
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(475, 140, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.fillText('Cilk', 510, 145);
        })();
    </script>
</body>
</html>
